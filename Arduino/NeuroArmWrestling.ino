#include <TimerOne.h> // подключаем библиотеку TimerOne для задействования функций Таймера1 
/* предварительно данную библиотеку надо установить, для чего скачиваем ее 
на странице http://www.bitronicslab.com/guide/ , распаковываем архив и помещаем папку TimerOne
внутрь папки libraries, находящейся тут: "Мои документы/Arduino/libraries" 
Подробнее о TimerOne см. тут: http://robocraft.ru/blog/arduino/614.html */

#define arrSize 32                           // размер массива оцифрованных значений для поиска в нем максимума и минимума сигнала
int sData1 = 0;                              // амплитуда размаха ЭМГ-сигнала у первого участника
int sData2 = 0;                              // амплитуда размаха ЭМГ-сигнала у второго участника
int val1[arrSize];                           // массив для хранения оцифрованных значений ЭМГ-сигнала первого участника
int val2[arrSize];                           // массив для хранения оцифрованных значений ЭМГ-сигнала второго участника
int i = 0;                                   // переменная-счётчик 
int emg1 = 0;                                // переменная для хранения оцифрованного значения сигнала первого участника 
int emg2 = 0;                                // переменная для хранения оцифрованного значения сигнала второго участника 
int maxV1 = 0, minV1 = 0;                    // переменные для хранения максимального и минимального значений ЭМГ-сигнала в массиве val1[] 
int maxV2 = 0, minV2 = 0;                    // переменные для хранения максимального и минимального значений ЭМГ-сигнала в массиве val2[] 

// функция sendData вызывается каждый раз, когда срабатывает прерывание Таймера1 (проходит заданное число микросекунд)
void sendData() {                            
  emg1 = analogRead(A1);                     // записываем в переменную emg1 оцифрованное значение сигнала с ножки А1 на Arduino.  
  emg2 = analogRead(A3);                     // записываем в переменную emg2 оцифрованное значение сигнала с ножки А3 на Arduino.
                                             // emg1, emg2 могут принимать значения в диапазоне от 0 до 1023, см. http://arduino.ru/Reference/AnalogRead 
  val1[i] = map(emg1, 0, 1023, 0, 255);      // записываем в элемент массива val1[i] переменную emg1, предварительно отнормированную на диапазон значений от 0 до 255,
  val2[i] = map(emg2, 0, 1023, 0, 255);      // записываем в элемент массива val2[i] переменную emg2, предварительно отнормированную на диапазон значений от 0 до 255,                                      
                                             // см. описание команды map:  http://arduino.ru/Reference/Map 
  i++;                                       // инкрементируем (увеличиваем на 1) значение переменной-счетчика
  
  if (i == arrSize) {                        // если полностью заполнили массивы
    i = 0;                                   // сбрасываем значение переменной-счетчика в 0
    
    // Ищем максимальное и минимальное значение ЭМГ-сигнала в массивах val1[] и val2[]  
    for (int k = 0; k < arrSize; k++) {      // создаем цикл for c переменной-итератором k и начинаем перебирать элементы массивов val1[] и val2[]
      if (val1[k] > maxV1)                   // если элемент массива val1[k] больше, чем значение ранее записанное в переменной для хранения максимумов maxV1,
        maxV1 = val1[k];                     // обновляем значение maxV1
      if (val1[k] < minV1)                   // если же элемент массива val1[k] меньше, чем значение ранее записанное в переменной для хранения минимумов minV1,
        minV1 = val1[k];                     // обновляем значение minV1
      if (val2[k] > maxV2)                   // если элемент массива val2[k] больше, чем значение ранее записанное в переменной для хранения максимумов maxV2,
        maxV2 = val2[k];                     // обновляем значение maxV2
      if (val2[k] < minV2)                   // если же элемент массива val2[k] меньше, чем значение ранее записанное в переменной для хранения минимумов minV2,
        minV2 = val2[k];                     // обновляем значение minV2
    }
    sData1 = maxV1 - minV1;                  // определяем максимальный размах сигнала ЭМГ, записанного в массив val1[]
    sData2 = maxV2 - minV2;                  // определяем максимальный размах сигнала ЭМГ, записанного в массив val2[]


    if (sData1 < 140 & sData2 < 140)         // если значение амплитуд у обоих участников ниже порогового (данное значение определяется экспериментально) 
    {                                        // оба светодиода не горят
      digitalWrite(12, LOW);                 // данное положение соответствует раслабленному состоянию участников
      digitalWrite(13, LOW);
    }
    else if (sData2 > sData1)                // если амплитуда сигнала второго участника больше первого 
    {                                        // горит светодиод (12 пин)
      digitalWrite(12, HIGH);
      digitalWrite(13, LOW);
    }
    else if (sData1 > sData2)                // если амплитуда сигнала первого участника больше второго 
    {                                        // горит светодиод (13 пин)
      digitalWrite(13, HIGH);
      digitalWrite(12, LOW);
    }
    
    maxV1 = 0;                               // обнуляем значение переменной maxV1, в которой хранится значение максимального элемента массива val1[] 
    minV1 = 0;                               // обнуляем значение переменной minV1, в которой хранится значение минимального элемента массива val1[]
    maxV2 = 0;                               // обнуляем значение переменной maxV2, в которой хранится значение максимального элемента массива val2[] 
    minV2 = 0;                               // обнуляем значение переменной minV2, в которой хранится значение минимального элемента массива val2[]
  }
  //Serial.write("A1");                      // записываем в Serial-порт имя поля в программе для визуализации, куда надо выводить сигнал
  //Serial.write(val1[i]);                   // всего в этой программе 4 поля, которые имеют имена A0, A1, A2, A3 (сверху вниз, по порядку их 
  //Serial.write("A3");                      // расположения в окне программы)
  //Serial.write(val2[i]); 

  Serial.write(0);                           // записываем в Serial-порт номер участника, чьи данные об амплитуде передаются следом за ним                                             
  Serial.write(sData1);                      // работая с программой на языке Python, мы в любой момент можем точно установить какого участника данные 
  Serial.write(1);
  Serial.write(sData2);
  }

// функция setup вызывается однократно при запуске Arduino
void setup() {
  pinMode(13, OUTPUT);                       // инициализируем цифровые пины 12 и 13 в качестве выхода
  pinMode(12, OUTPUT);
  Serial.begin(115200);                      // инициализируем Serial-порт на скорости 115200 Кбит/c. 
                                             // такую же скорость надо установить в программе для визуализации
  Timer1.initialize(8334);                   // инициализируем Таймер1, аргументом указываем интервал срабатывания - 8334 микросекунд 
                                             // (1 000 000 микросекунд = 1 сек)
  Timer1.attachInterrupt(sendData);          // как только проходит 8334 микросекунд - наступает прерывание (вызывается функция sendData)

  for (int k = 0; k < arrSize; k++){
    val1[k] = 0;                             // заполняем массив val1 нулями
  }
  for (int k = 0; k < arrSize; k++){
    val2[k] = 0;                             // заполняем массив val2 нулями
  }
}

void loop(){
// а в бесконечном цикле мы ничего не делаем. Таймер1 сам будет вызывать функцию sendData через каждые 8334 микросекунд
  }
